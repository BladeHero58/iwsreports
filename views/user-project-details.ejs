<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
    <!-- Handsontable CSS -->
    <script src="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@latest/dist/handsontable.full.min.css"></script>
       <!-- Undo - Redo CSS-->
     <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

     <style>
        #hot-container {
          max-width: 794px;
          margin: 0 auto;
          overflow-x: auto;
        }
    
        .handsontable {
          font-size: 15px;
          line-height: 1.2;
        }
    
        @media print {
          #hot-container {
            max-width: 100% !important;
            overflow: visible !important;
          }
    
          .handsontable {
            font-size: 8px !important;
          }
    
          htCore td {
            padding: 2px !important;
          }
        }

        .black-cell {
    background-color: black !important;
    color: yellow !important;
    border-color: yellow !important;
    font-weight: bold !important;
    font-size: 16px !important;
}
.yellow-row {
    background-color: yellow !important;
}

.white-row {
    background-color: white !important;
}

.htCenter {
    text-align: center; /* For horizontal centering */
    vertical-align: middle; /* For vertical centering */
  }

  /* Új stílusok az első sorhoz */
  .first-row-style {
        text-align: center !important; /* Vízszintes középre igazítás */
        font-size: 22px !important; /* 22px betűméret */
        background-color: #ffffff !important; /* Például szürke háttér */
        color: black !important; /* Például fekete szöveg */
        font-weight: bold !important;
        text-align: center !important; /* Vízszintes középre igazítás */
        vertical-align: middle !important; /* Függőleges középre igazítás */
        text-decoration: underline !important;
    }

    /* Új stílusok a 11. sorhoz */
    .eleventh-row-style {
        text-align: center !important; /* Vízszintes középre igazítás */
        vertical-align: middle !important; /* Függőleges középre igazítás */
    }

    /* ÚJ stílusok az utolsó sorhoz */
    .last-row-style {
        font-weight: bold !important; /* Félkövér szöveg */
        background-color: lightgrey !important; /* Világosszürke háttér */
        font-size: 18px !important;
        text-align: center !important; /* Vízszintes középre igazítás */
    }

    /* Specifikusabb szabály a beszúrt sorokra */
.handsontable tr.beszurt-sor { /* vagy valamilyen más egyedi osztály */
    height: 70px !important; /* vagy a kívánt magasság */
}

.vertical-text {
    writing-mode: vertical-lr; /* Balról jobbra, függőlegesen */
    /* vagy */
    /* writing-mode: vertical-rl; /* Jobbról balra, függőlegesen */
}

.cell-centered {
    text-align: center !important;
    vertical-align: middle !important;
}
      </style>

    <title>Projekt részletei</title>

    <link rel="stylesheet" href="/css/pages/user-project-details-style.css">

</head>
<body>
    <h1>Projekt részletei</h1>

    <h2><%= project.name %></h2>
    <p><strong>Leírás:</strong> <%= project.description %></p>
    <p><strong>Állapot:</strong> <%= project.status %></p>
    <p><strong>Projekt ID:</strong> <%= project.id %></p>

    <section>
        <!-- Szerkesztés gomb -->
        <a href="/user/projects/edit/<%= project.id %>">
            <button type="submit" class="btn">Projekt szerkesztése</button>
        </a>
    </section>
    
    <!-- Rejtett input mező a projectId-hoz -->
    <input type="hidden" id="projectId" value="<%= project.id %>">
     
    <!-- Gombok -->
    <button id="generateReportBtn" type="submit" class="btn">Új jegyzőkönyv generálása</button>
    <button id="loadReportBtn" type="submit" class="btn">Legutóbbi jegyzőkönyv</button>
    <button id="saveReportBtn" type="submit" class="btn">Jegyzőkönyv mentése</button>

    <a href="/reports/fine-list" target="_blank">
        <button type="submit" class="btn">Szankciós lista</button>
    </a>

    <button id="undo" class="btn-blue" style="font-size:10px">
        <i class="material-icons">undo</i>
    </button>
    
    <button id="redo" class="btn-blue" style="font-size:10px">
        <i class="material-icons">redo</i>
    </button>

    <div id="tableContainer" style="margin-top: 20px;"></div>

    <script src="https://cdn.jsdelivr.net/npm/handsontable@12.3.1/dist/handsontable.min.js"></script>
    <script>
        
        //project id mező
        const projectId = document.getElementById('projectId').value; 
        console.log('Aktuális projekt ID:', projectId);

   // Kép megjelenítő renderer (MÓDOSÍTOTT)
const imageRenderer = (instance, td, row, col, prop, value, cellProperties) => {
    // Töröljük a meglévő tartalmat
    while (td.firstChild) {
        td.removeChild(td.firstChild);
    }

    // MÓDOSÍTÁS: Most már a GCS URL-eket is kezeljük
    if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
        // Konténer div létrehozása
        const container = document.createElement('div');
        container.style.width = '100%';
        container.style.height = '100%';
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.justifyContent = 'center';
        container.style.overflow = 'hidden';
        container.style.position = 'relative';

        // Forgatási érték lekérése
        let rotation = instance.getCellMeta(row, col).rotation || 0;

        // Kép elem létrehozása
        const img = document.createElement('img');
        img.src = value; // A 'value' már a GCS URL vagy Data URI lesz

        // Forgatás alkalmazása
        img.style.position = 'absolute';
        img.style.transformOrigin = 'center';
        img.style.transform = `rotate(${rotation}deg)`;

        // Méretezés
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';

        container.appendChild(img);
        td.appendChild(container);
    }

    // Cella padding eltávolítása
    td.style.padding = '0';
    td.style.overflow = 'hidden';

    return td;
};

// Kezdeti cella stílusok beállítása a táblázat létrehozásakor (MÓDOSÍTOTT)
const setupInitialCellStyles = (hot, data) => {
    console.log("Frontend oldali data.cellStyles a setupInitialCellStyles függvényben:", data.cellStyles);
    if (data.cellStyles && Array.isArray(data.cellStyles)) {
        data.cellStyles.forEach(style => {
            const row = style.row;
            const col = style.col;
            const value = hot.getDataAtCell(row, col);

            console.log(`setupInitialCellStyles: Sor=${row}, Oszlop=${col}, Stílus=${JSON.stringify(style)}`);

            // Kép renderer és forgatás beállítása
            // MÓDOSÍTÁS: Most már a GCS URL-eket is kezeljük
            if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                hot.setCellMeta(row, col, 'renderer', imageRenderer);
                if (style.rotation !== undefined) {
                    hot.setCellMeta(row, col, 'rotation', style.rotation);
                }
            }

            // Egyéb stílusok beállítása a cellMeta-ban
            if (style.backgroundColor) {
                hot.setCellMeta(row, col, 'backgroundColor', style.backgroundColor);
            }
            if (style.color) {
                hot.setCellMeta(row, col, 'color', style.color);
            }
            if (style.fontWeight) {
                hot.setCellMeta(row, col, 'fontWeight', style.fontWeight);
            }
            if (style.fontSize) {
                hot.setCellMeta(row, col, 'fontSize', style.fontSize);
            }
            if (style.textAlign) {
                hot.setCellMeta(row, col, 'textAlign', style.textAlign);
            }
            if (style.borderColor) {
                hot.setCellMeta(row, col, 'borderColor', style.borderColor);
            }
            if (style.className) {
                hot.setCellMeta(row, col, 'className', style.className);
            }
            if (style.rotation !== undefined) {
                hot.setCellMeta(row, col, 'rotation', style.rotation);
            }
        });

        hot.render();
    }
};

// Export Json-ba
function exportToJson(hotInstance) {
    const json = hotInstance.getData().map((row, rowIndex) => {
        return row.map((cell, colIndex) => {
            const cellMeta = hotInstance.getCellMeta(rowIndex, colIndex);
            if (cellMeta.renderer === imageRenderer) {
                // Ha a cella már tartalmaz data URI-t, használd azt
                if (typeof cell === 'string' && cell.startsWith('data:image')) {
                    return cell;
                } else {
                    // Ha csak base64 string, formázd data URI-vá
                    return `data:image/png;base64,${cell}`;
                }
            }
            return cell;
        });
    });
    return json;
}

// Sorszámozás frissítése függvény - utolsó 10 sorban nem módosít semmit
function updateRowNumbers(hot) {
    const rowCount = hot.countRows();
    
    // Ne számozzuk az utolsó 10 sort
    const lastNumberedRow = rowCount - 11; // Az utolsó számozott sor indexe
    
    // Csak a 11. és az utolsó 10 sor közötti sorokat számozzuk
    let counter = 1; // Kezdő sorszám
    
    for (let row = 11; row <= lastNumberedRow; row++) {
        // A 0. oszlopba beírjuk a sorszámot
        hot.setDataAtCell(row, 0, counter.toString());
        counter++;
    }
    
    // Az utolsó 10 sort nem módosítjuk, meghagyjuk az eredeti tartalmukat
}

// Handsontable inicializálása
let hot;

// Undo/Redo eseménykezelők hozzáadása
document.getElementById('undo').addEventListener('click', () => {
    if (hot) {
        hot.undo();
    }
});

document.getElementById('redo').addEventListener('click', () => {
    if (hot) {
        hot.redo();
    }
});

// Handsontable további inicializálása
function displayEditableTable(data, mergeCells, colWidths, rowHeights) {
    const container = document.getElementById('tableContainer');

    // Ellenőrizzük, hogy a hot létezik-e és még nem lett elpusztítva
    if (hot && !hot.isDestroyed) {
        hot.destroy();
    }

    // Dropdown opciók definíciója
    const typeOptions = [
        'Munkaterületre való lejutás/feljutás', 'Lehatárolás, elkerítés', 'Viselkedés',
        'Vegyianyagok', 'Beszállásos munka', 'Emelőgépek, emeléshez használt eszközök',
        'Emelési művelet', 'Dokumentációk, Iratok', 'Munkaterületen való közlekedés (jármű)',
        'Elektromos hibák', 'Környezetkárosító hatások', 'Földmunka', 'Leesés elleni védelem',
        'Tűzvédelem', 'Egészséget károsító', 'Tűzveszélyes munka', 'Rendtartás', 'Megvilágítás',
        'Felülvzsgálatok, tesztek', 'LMRA, Toolbox, Munkavégzés előtti megbeszélés',
        'Anyag rendezés', 'Zajterhelés', 'Egyéni védőeszközök', 'Állványozás, Munkaeszközök',
        'Munka organizáció', 'Munkaengedély', 'Hulladékkezelés', 'Csúszás- és botlásveszély',
        'Átszúrás elleni védelem', 'Jelölések', 'Gázpalack tárolás',
        'Munkaterületen való közlekedés (gyalogos)', 'Nem besorolt'
    ];

    const categoryOptions = [
        'Nem biztonságos munkavégzés',
        'Nem biztonságos állapot',
        'Jó gyakorlat'
    ];

const riskOptions = [
    { value: 'Alacsony', color: '#ffff00' },
    { value: 'Közepes', color: '#ed7d31' },
    { value: 'Magas', color: '#ff0000' },
    { value: '-', color: 'white' } // Ez a sor most már "white", de a kódban dinamikusan felülírjuk
];

const statusOptions = [
    { value: 'Nyitott', color: '#ff0000' },
    { value: 'Lezárt', color: '#92d050' },
    { value: 'Folyamatban', color: '#ffff00' },
    { value: 'Nem teljesített', color: 'grey' },
    { value: 'Felszólítás után teljesítve', color: '#ffd966' },
    { value: 'NA', color: 'white' } // Hasonlóan, ezt is dinamikusan felülírjuk
];

// Egyedi renderer a színes cellákhoz
function colorRenderer(instance, td, row, col, prop, value, cellProperties) {
    Handsontable.renderers.TextRenderer.apply(this, arguments);

    if (cellProperties.type === 'dropdown') {
        Handsontable.renderers.DropdownRenderer.apply(this, arguments);
    }

    const rowCount = instance.countRows();
    const tenthRowFromBottom = rowCount - 10;

    if (row === tenthRowFromBottom && (col === 0 || col === 1)) {
        td.style.backgroundColor = 'black';
        td.style.color = 'yellow';
        td.style.fontWeight = 'bold';
        instance.setCellMeta(row, col, 'backgroundColor', 'black');
        instance.setCellMeta(row, col, 'color', 'yellow');
        instance.setCellMeta(row, col, 'fontWeight', 'bold');
        return;
    }

    if ((row < 7 && row > 2) || row === 8 || row === 10) {
        td.style.backgroundColor = 'black';
        td.style.color = 'yellow';
        td.style.fontWeight = 'bold';
        instance.setCellMeta(row, col, 'backgroundColor', 'black');
        instance.setCellMeta(row, col, 'color', 'yellow');
        instance.setCellMeta(row, col, 'fontWeight', 'bold');
        return;
    }

    // --- MÓDOSÍTOTT KÓD ---
    if (col === 7) {
        // Ha az érték '-', akkor dinamikusan állítjuk be a színt
        if (value === '-') {
            const rowColor = getRowColor(row, instance);
            td.style.backgroundColor = rowColor;
            td.style.color = 'black'; // A szöveg színe maradjon fekete
            instance.setCellMeta(row, col, 'backgroundColor', rowColor);
            instance.setCellMeta(row, col, 'color', 'black');
            return;
        }

        const riskOption = riskOptions.find(option => option.value === value);
        if (riskOption) {
            td.style.backgroundColor = riskOption.color;
            td.style.color = 'black';
            instance.setCellMeta(row, col, 'backgroundColor', riskOption.color);
            instance.setCellMeta(row, col, 'color', 'black');
            return;
        }
    }

    // --- MÓDOSÍTOTT KÓD ---
    if (col === 10) {
        // Ha az érték 'NA', akkor dinamikusan állítjuk be a színt
        if (value === 'NA') {
            const rowColor = getRowColor(row, instance);
            td.style.backgroundColor = rowColor;
            td.style.color = 'black'; // A szöveg színe maradjon fekete
            instance.setCellMeta(row, col, 'backgroundColor', rowColor);
            instance.setCellMeta(row, col, 'color', 'black');
            return;
        }
        
        const statusOption = statusOptions.find(option => option.value === value);
        if (statusOption) {
            td.style.backgroundColor = statusOption.color;
            td.style.color = 'black';
            instance.setCellMeta(row, col, 'backgroundColor', statusOption.color);
            instance.setCellMeta(row, col, 'color', 'black');
            return;
        }
    }

    if (value && (value.startsWith('data:image') || value.startsWith('/uploads/'))) {
        return;
    }

    // Először a 'backgroundColor' metaadatot ellenőrizzük
    const storedBackgroundColor = cellProperties.backgroundColor;
    if (storedBackgroundColor) {
        td.style.backgroundColor = storedBackgroundColor;
        td.style.color = storedBackgroundColor === 'black' ? 'yellow' : 'black';
        return;
    }

    // Ha nincs 'backgroundColor', akkor nézzük a 'color' metaadatot a beszúrt sorokhoz
    const storedColor = cellProperties.color;
    if (row >= 11 && row < tenthRowFromBottom && storedColor) {
        td.style.backgroundColor = storedColor;
        td.style.color = 'black'; // A szöveg színe maradjon fekete a beszúrt sorokban
        return;
    }

    // Ha nincs tárolt szín a metaadatokban, akkor nézzük a localStorage-t
    const rowColors = JSON.parse(localStorage.getItem('rowColors')) || {};
    if (rowColors[row]) {
        td.style.backgroundColor = rowColors[row];
        td.style.color = rowColors[row] === 'black' ? 'yellow' : 'black';
        return;
    }

    // Beszúrt dinamikus sorok alternáló színezése (átdolgozva)
    if (row >= 11 && row < tenthRowFromBottom) {
        // Az eltolás biztosítja, hogy az első dinamikus sor fehér legyen
        const isEven = (row - 11) % 2 === 0;
        const backgroundColor = isEven ? 'white' : '#D7D7D7';
        td.style.backgroundColor = backgroundColor;
        td.style.color = 'black';
        
        // Beállítjuk a metaadatot és mentjük a LocalStorage-ba is
        instance.setCellMeta(row, col, 'backgroundColor', backgroundColor);
        instance.setCellMeta(row, col, 'color', 'black');
        
        // Frissítjük a rowColors objektumot
        if (!rowColors[row]) {
            rowColors[row] = backgroundColor;
            localStorage.setItem('rowColors', JSON.stringify(rowColors));
        }
    }
}

// Dinamikusan meghatározza a sor színét
function getRowColor(row, hotInstance) {
    if ((row < 7 && row > 2) || row === 10) {
        return 'black';
    }

    // Az első 11 sor színe ne változzon alapértelmezetten
    if (row < 11) {
        return ''; // Vagy 'white', ha alapértelmezetten fehérnek kell lennie
    }

    const rowCount = hotInstance.countRows();
    const tenthRowFromBottom = rowCount - 10;
    
    // Ha az utolsó 10 sorban vagyunk, nem alkalmazunk színt
    if (row >= tenthRowFromBottom) {
        return '';
    }
    
    // Beszúrt dinamikus sorok - az első FEHÉR legyen, nem szürke
    const isEven = (row - 11) % 2 === 0;
    return isEven ? 'white' : '#D7D7D7';
}

// A getInitialRowColor függvényt is módosítjuk
function getInitialRowColor(row, hotInstance) {
    const rowCount = hotInstance.countRows();
    const tenthRowFromBottom = rowCount - 10;
    
    if ((row < 7 && row > 2) || row === 10) return 'black';
    
    // A 11. sortól az utolsó 10 sor kezdetéig alkalmazzuk a váltakozó színeket
    if (row >= 11 && row < tenthRowFromBottom) {
        const isEven = (row - 11) % 2 === 0;
        return isEven ? 'white' : '#D7D7D7';
    }
    
    return ''; // Alapértelmezett érték
}
    
// Define saveRowColor (módosítva, hogy figyelembe vegye az első 11 sort)
function saveRowColor(row, color) {
    const rowColors = JSON.parse(localStorage.getItem('rowColors')) || {};
    
    // A dinamikus sorok színeinek mentése
    if (row >= 11) {
        rowColors[row] = color;
        localStorage.setItem('rowColors', JSON.stringify(rowColors));
    }
}

// Define loadRowColors (módosítva)
function loadRowColors(hotInstance) {
    console.log("loadRowColors függvény meghívva");

    const rowColors = JSON.parse(localStorage.getItem('rowColors')) || {};
    console.log("Betöltött sor színek:", rowColors);

    const rows = hotInstance.countRows();
    const cols = hotInstance.countCols();
    const lastTenRowsStart = rows - 10;

    for (let row = 0; row < rows; row++) {
        // Hagyjuk ki a fekete sorokat ÉS az utolsó 10 sort
        if ((row < 7 && row > 2) || row === 8 || row === 10 || row >= lastTenRowsStart) continue;

        if (rowColors[row]) {
            console.log(`Szín alkalmazása a ${row}. sorra: ${rowColors[row]}`);
            for (let col = 0; col < cols; col++) {
                hotInstance.setCellMeta(row, col, 'renderer', colorRenderer);
                hotInstance.setCellMeta(row, col, 'color', rowColors[row]);
            }
        } else if (row >= 11 && row < lastTenRowsStart) {
            // Módosított sor a váltakozó színezéshez - az első dinamikus sor FEHÉR
            const isEven = (row - 11) % 2 === 0;
            const color = isEven ? 'white' : '#D7D7D7';
            
            for (let col = 0; col < cols; col++) {
                hotInstance.setCellMeta(row, col, 'renderer', colorRenderer);
                hotInstance.setCellMeta(row, col, 'backgroundColor', color);
                hotInstance.setCellMeta(row, col, 'color', 'black');
            }
            
            // Mentsük el a színt a localStorage-ba is
            rowColors[row] = color;
        } else if (row >= lastTenRowsStart) {
            // Az utolsó 10 sorban töröljük a 'color' és 'backgroundColor' metaadatot
            for (let col = 0; col < cols; col++) {
                hotInstance.setCellMeta(row, col, 'color', undefined);
                hotInstance.setCellMeta(row, col, 'backgroundColor', undefined);
            }
        }
    }
    
    // Mentsük el a frissített színeket
    localStorage.setItem('rowColors', JSON.stringify(rowColors));

    hotInstance.render();
    console.log("Sorszínek betöltve és alkalmazva");
}

console.log("A data objektum a Handsontable inicializálása előtt:", data);
    //Handsontable inicializálása
    hot = new Handsontable(container, {
        data: data,
        colHeaders: true,
        rowHeaders: true,
        undo: true, // Engedélyezi az undo/redo funkcionalitást
        redo: true,
        contextMenu: {
            items: {
                "row_above": {
  name: "Sor beszúrása felülre",
  callback: function(key, selection) {
    const row = selection[0].start.row;
    this.alter('insert_row_above', row);
    const rowHeights = this.getSettings().rowHeights;
    rowHeights.splice(row, 0, 180);
    this.updateSettings({ rowHeights: rowHeights });
    const cols = this.countCols();
    for (let col = 0; col < cols; col++) {
      if (row < 7 || row === 10) continue;
      this.setCellMeta(row, col, 'renderer', colorRenderer);
      // A szín a getRowColor függvényben dinamikusan generálódik
    }
    // Sorszámozás frissítése
    if (row >= 11) {
      updateRowNumbers(this);
    }
    this.render();
  }
},
"row_below": {
  name: "Sor beszúrása alulra",
  callback: function(key, selection) {
    const row = selection[0].start.row;
    this.alter('insert_row_below', row);
    const rowHeights = this.getSettings().rowHeights;
    rowHeights.splice(row + 1, 0, 180);
    this.updateSettings({ rowHeights: rowHeights });
    const cols = this.countCols();
    for (let col = 0; col < cols; col++) {
      if (row + 1 < 7 || row + 1 === 10) continue; // +1 az alsó beszúráshoz
      this.setCellMeta(row + 1, col, 'renderer', colorRenderer);
      // A szín a getRowColor függvényben dinamikusan generálódik
    }
    // Sorszámozás frissítése
    if (row >= 10) { // Alulra beszúrás esetén már a 10. sortól
      updateRowNumbers(this);
    }
    this.render();
  }
},
                "remove_row": {name: "Sor eltávolítása"},
                "upload_image": {
    name: "Kép feltöltése",
    callback: function () {
        const coords = hot.getSelected()[0];
        const projectId = document.getElementById('projectId').value; // Projekt ID lekérése

        if (!projectId) {
            alert('Kérlek válassz egy projektet!');
            return; // Kilépés, ha nincs projectId
        }

        if (coords) {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';

            fileInput.addEventListener('change', function (event) {
                const file = event.target.files[0];
                if (file) {
                    const formData = new FormData();
                    formData.append('image', file);
                    formData.append('projectId', projectId); // Projekt ID hozzáadása

                    // A backend feltöltési útvonala nem változik
                    fetch('/reports/upload', {
                        method: 'POST',
                        body: formData,
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.url) {
                            // A backend most már GCS URL-t ad vissza
                            hot.setDataAtCell(coords[0], coords[1], data.url); // Frissítjük a cellát az új URL-lel
                            hot.setCellMeta(coords[0], coords[1], 'renderer', imageRenderer); // Renderer hozzáadása
                            hot.render(); // Frissítjük a táblázatot
                        } else {
                            alert('Hiba történt a feltöltés során.');
                        }
                    })
                    .catch(error => {
                        console.error('Kép feltöltési hiba:', error);
                        alert('Hiba történt a fájl feltöltésekor.');
                    });
                }
            });

            fileInput.click();
        } else {
            alert('Kérlek válassz egy cellát a kép feltöltéséhez!');
        }
    }
},
              "rotate_image": {
    name: "Kép forgatása 90° jobbra",
    callback: function() {
        const coords = hot.getSelected()[0];
        if (coords) {
            const row = coords[0];
            const col = coords[1];
            const value = hot.getDataAtCell(row, col);

            // MÓDOSÍTÁS: A feltétel most már a GCS URL-t is kezeli
            if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                // Get current rotation or default to 0
                let currentRotation = hot.getCellMeta(row, col).rotation || 0;

                // Add 90 degrees (modulo 360 to keep it between 0-359)
                let newRotation = (currentRotation + 90) % 360;

                // Always ensure the renderer is set before setting rotation
                hot.setCellMeta(row, col, 'renderer', imageRenderer);
                hot.setCellMeta(row, col, 'rotation', newRotation);

                // Explicitly log the new rotation to verify (can be removed in production)
                console.log(`Image rotated: row=${row}, col=${col}, rotation=${newRotation}`);

                hot.render();
            }
        }
    }
},
                "remove_image": {
    name: "Kép eltávolítása",
    callback: function () {
        const coords = hot.getSelected()[0];
        if (coords) {
            const value = hot.getDataAtCell(coords[0], coords[1]);

            // MÓDOSÍTÁS: A feltétel most már a GCS URL-t is kezeli
            if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                // Ha Base64 adat URI, akkor nem küldünk törlési kérést,
                // mert az nincs külön fájlként tárolva a GCS-en.
                // Ha GCS URL, akkor küldünk törlési kérést.
                const imageUrlToDelete = value.startsWith('https://storage.googleapis.com/') ? value : null;

                hot.setDataAtCell(coords[0], coords[1], null); // Töröljük a cella tartalmát
                hot.removeCellMeta(coords[0], coords[1], 'renderer'); // Eltávolítjuk a renderer meta adatot
                hot.render(); // Frissítjük a táblázatot

                if (imageUrlToDelete) {
                    // Itt a backend /reports/delete-image endpointjának is tudnia kell
                    // GCS-ről törölni a fájlt az imageUrlToDelete alapján!
                    fetch('/reports/delete-image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ imageUrl: imageUrlToDelete }),
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('Kép sikeresen törölve a Google Cloud Storage-ről');
                        } else {
                            console.error('Hiba a kép törlésében a Google Cloud Storage-ről:', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Hiba a szerverrel való kommunikációban kép törlésekor:', error);
                    });
                                }
                            }
                        }
                    }
                }
            }
        },
        manualRowInsert: true,
        manualColumnInsert: true,
        manualRowMove: true,
        manualColumnMove: true,
        manualRowResize: true,
        manualColumnResize: true,
        licenseKey: 'non-commercial-and-evaluation',
        mergeCells: mergeCells, // Egyesített cellák beállítása
        colWidths: Array.isArray(colWidths) && colWidths.length > 0 ? colWidths : undefined,
        rowHeights: Array.isArray(rowHeights) && rowHeights.length > 0 ? rowHeights : undefined,
        // Oszlopok konfigurációja
        columns: [
            { type: 'text' }, // 0-5 oszlop - szöveg típusúak maradnak
            { type: 'text' },
            { type: 'text' },
            { type: 'text' },
            { type: 'text' },
            {
                type: 'dropdown', // 6. oszlop - dropdown típus
                source: function(query, process) { // Forrás dinamikus beállítása
                    if (hot.getSelectedLast()[0] >= 7 && hot.getSelectedLast()[0] !== 10) { // Csak a beszúrt sorokra
                        process(typeOptions);
                    } else {
                        process([]); // Egyéb sorokra üres lista
                    }
                }
            },
            {
                type: 'dropdown', // 7. oszlop - dropdown típus
                source: function(query, process) { // Forrás dinamikus beállítása
                    if (hot.getSelectedLast()[0] >= 7 && hot.getSelectedLast()[0] !== 10) { // Csak a beszúrt sorokra
                        process(categoryOptions);
                    } else {
                        process([]); // Egyéb sorokra üres lista
                    }
                }
            },
            {
                type: 'dropdown', // 8. oszlop - dropdown típus
                source: function(query, process) { // Forrás dinamikus beállítása
                    if (hot.getSelectedLast()[0] >= 7 && hot.getSelectedLast()[0] !== 10) { // Csak a beszúrt sorokra
                        process(riskOptions.map(option => option.value)); // Fontos: csak az értékeket adjuk át a forráshoz, nem a teljes objektumot
                    } else {
                        process([]); // Egyéb sorokra üres lista
                    }
                },
                renderer: colorRenderer // Alkalmazzuk a colorRenderer-t a 8. oszlopra
            },
            { type: 'text' },
            { type: 'text' },
            {
                type: 'dropdown', // 11. oszlop - dropdown típus
                source: function(query, process) { // Forrás dinamikus beállítása
                    if (hot.getSelectedLast()[0] >= 7 && hot.getSelectedLast()[0] !== 10) { // Csak a beszúrt sorokra
                        process(statusOptions.map(option => option.value));
                    } else {
                        process([]); // Egyéb sorokra üres lista
                    }
                },
                renderer: colorRenderer // Alkalmazzuk a colorRenderer-t a 11. oszlopra is
            },
            { type: 'text' }
        ],
        beforeChange: function(changes, source) {
  if (source === 'insert_row_above' || source === 'insert_row_below') {
    const rowHeights = this.getSettings().rowHeights || [];
    const rowCount = this.countRows();
    while (rowHeights.length < rowCount) {
      rowHeights.push(undefined); // Alapértelmezett magasság
    }
    for (let i = 0; i < rowCount; i++) {
      if (i < 7 || i === 10) continue;
      if (!rowHeights[i]) {
        rowHeights[i] = 180;
      }
    }
    this.updateSettings({ rowHeights: rowHeights });
  }
},
afterCreateRow: function(index, amount) {
  const cols = this.countCols();
  for (let col = 0; col < cols; col++) {
    if (index < 7 || index === 10) continue;
    this.setCellMeta(index, col, 'renderer', colorRenderer);
    // Új: A szín dinamikus beállítása a cellMeta-ban
    const rowColor = getRowColor(index, this);
    if (rowColor) {
      this.setCellMeta(index, col, 'color', rowColor);
    }
  }
  this.render();
},
// Adjunk hozzá egy beforeRender hook-ot
beforeRender: function(isForced) {
    // Végigmegyünk az összes cellán
    const rows = this.countRows();
    const cols = this.countCols();
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const value = this.getDataAtCell(row, col);
            // MÓDOSÍTÁS: GCS URL-ek kezelése
            if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                this.setCellMeta(row, col, 'renderer', imageRenderer);
            }
        }
    }
},

        // Adjunk hozzá egy afterLoadData hook-ot
       afterLoadData: function(initialLoad) {
    if (initialLoad) {
        // Cellastílusok visszaállítása
        if (data.cellStyles && Array.isArray(data.cellStyles)) {
            data.cellStyles.forEach(style => {
                const row = style.row;
                const col = style.col;
                // Beállítjuk a renderereket és metaadatokat
                const value = this.getDataAtCell(row, col);
                // MÓDOSÍTÁS: GCS URL-ek kezelése
                if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                    this.setCellMeta(row, col, 'renderer', imageRenderer);
                    if (style.rotation !== undefined) {
                        this.setCellMeta(row, col, 'rotation', style.rotation);
                        console.log(`Kép forgatás visszaállítva: sor=${row}, oszlop=${col}, forgatás=${style.rotation}`);
                    }
                }
                if (style.color) {
                    // Itt nem állítjuk be a színt, mert a colorRenderer kezeli
                }
            });
            this.render(); // Újrarajzolás
        }
    }
},
        // Adjunk hozzá egy afterRemoveRow eseménykezelőt a Handsontable inicializálásához
        afterRemoveRow: function(index, amount) {
  const rowsRemoved = amount || 1;
  const storedColors = JSON.parse(localStorage.getItem('rowColors')) || {};
  const updatedColors = {};

  Object.keys(storedColors).forEach(rowStr => {
    const row = parseInt(rowStr);
    if (row < index) {
      updatedColors[row] = storedColors[row];
    } else if (row >= index + rowsRemoved) {
      updatedColors[row - rowsRemoved] = storedColors[row];
    }
  });
  localStorage.setItem('rowColors', JSON.stringify(updatedColors));

  const rowHeights = this.getSettings().rowHeights || [];
  if (Array.isArray(rowHeights) && rowHeights.length > 0) {
    rowHeights.splice(index, rowsRemoved);
    this.updateSettings({ rowHeights: rowHeights });
  }

  if (index >= 11) {
    updateRowNumbers(this);
  }
  this.render();
},
cells: function (row, col) {
    const cellMeta = {};
    const value = this.instance.getDataAtCell(row, col);
    const lastRowIndex = this.instance.countRows() - 1;
    const tenthFromLastRowIndex = lastRowIndex - 9; // Utolsó előtti 10. sor indexe

    // FEKETE CELLÁK BEÁLLÍTÁSA (hozzáadva a row === 10 feltétel)
    if ((row < 7 && row > 2) || row === 8 || row === 10 || (row === tenthFromLastRowIndex && (col === 0 || col === 1))) {
        cellMeta.renderer = 'html';
        cellMeta.className = cellMeta.className ? cellMeta.className + ' black-cell' : 'black-cell';
    }

    // KÖZÉPRE IGAZÍTÁS az utolsó sortól visszafelé számolt 10. sor első két cellájában
    if (row === tenthFromLastRowIndex && (col === 0 || col === 1)) {
        const style = {
            'display': 'flex',
            'justify-content': 'center',
            'align-items': 'center',
            'text-align': 'center'  // Horizontális igazítás biztosítása
        };
        cellMeta.style = style;
        // Adjunk hozzá egy extra osztályt a középre igazításhoz
        cellMeta.className = cellMeta.className ? cellMeta.className + ' cell-centered' : 'cell-centered';
    }

    // Egyéb fekete cellák esetén is középre igazítás, ha szükséges (hozzáadva a row === 10 feltétel)
    else if ((row < 7 && row > 2) || row === 8 || row === 10) {
        const style = {
            'display': 'flex',
            'justify-content': 'center',
            'align-items': 'center',
            'text-align': 'center' // Fontos a vízszintes igazítás!
        };
        cellMeta.style = style;
    }

    // MÓDOSÍTÁS: GCS URL-ek kezelése
    if (typeof value === 'string' && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
        cellMeta.renderer = imageRenderer;
        cellMeta.className = 'image-cell';
    }

    if (row === 0) {
        cellMeta.className = 'first-row-style';
    }

    if (row === 10) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' eleventh-row-style' : 'eleventh-row-style';
    }

    if (row === lastRowIndex) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' last-row-style' : 'last-row-style';
    }

    // Függőleges szöveg beállítása a 11. sor 1. oszlopában (ez már itt van)
    if (row === 10 && col === 0) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' vertical-text' : 'vertical-text';
    }

    // Függőleges szöveg beállítása az utolsótól visszafelé számított 10. sor 1. oszlopában
    if (row === tenthFromLastRowIndex && col === 0) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' vertical-text' : 'vertical-text';
    }

    // 8. sor és 11. sor középre igazítása, *mindig* (itt a 11. sorra vonatkozó rész már jó)
    if (row === 8 || row === 10) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' htCenter' : 'htCenter';
    }

    // 11. sor felett középre igazítás, *mindig* (de csak 5. oszloptól kezdve)
    if (row > 10 && col >= 5) {
        cellMeta.className = cellMeta.className ? cellMeta.className + ' htCenter' : 'htCenter';
    }

    return cellMeta;
},
    });
    loadRowColors(hot); // <--- IDE, közvetlenül a Handsontable létrehozása UTÁN
    // Új: Képek forgatásának explicit visszaállítása
    if (data.cellStyles && Array.isArray(data.cellStyles)) {
        setTimeout(() => {
            data.cellStyles.forEach(style => {
                if (style.rotation !== undefined) {
                    const row = style.row;
                    const col = style.col;
                    const value = hot.getDataAtCell(row, col);

                    // MÓDOSÍTÁS: GCS URL-ek kezelése
                    if (value && (value.startsWith('data:image') || value.startsWith('https://storage.googleapis.com/'))) {
                        hot.setCellMeta(row, col, 'renderer', imageRenderer);
                        hot.setCellMeta(row, col, 'rotation', style.rotation);
                        console.log(`Késleltetett kép forgatás beállítva: sor=${row}, oszlop=${col}, forgatás=${style.rotation}`);
                    }
                }
            });
            hot.render();
        }, 200); // Kis késleltetés a DOM frissítésének biztosítása érdekében
    }
    // Frissítsük a sorok színeit a táblázat inicializálásakor is
    if (hot && hot.render) {
        hot.render();
    }
}

// Új jegyzőkönyv generálása
document.getElementById('generateReportBtn').addEventListener('click', () => {
    const data = Array(22).fill().map(() => Array(12).fill(''));

    // Statikus tartalom beállítása
    data[0][3] = "Heti munkavédelmi bejárási jegyzőkönyv";
    data[0][1] = "Kép helye";
    data[0][9] = "Kép helye";
    data[3][1] = "Dátum:";
    data[3][6] = "Bejárást végezte:";
    data[4][1] = "Projekt megnevezése:";
    data[4][6] = "Telefonszám:";
    data[5][6] = "HSE megbízott:";
    data[5][7] = "IWS Solutions Kft.";
    data[5][1] = "Helyszín:";
    data[6][6] = "Cím:";
    data[6][7] = "2040 Budaörs (Terrapark), Puskás Tivadar út 14/C.";
    data[6][1] = "Építkezés jellege:";
    data[8][3] = "Észrevételek, megfigyelések, megjegyzések";
    data[11][0] = "1";
    data[16][3] = "Pecsét helye";

    data[10] = [
        "Sorszám", "Megfigyelés", "Megoldás/ Javaslat/ Megjegyzés",
        "Érintett Cég", "Fénykép", "Kategória", "Osztályozás",
        "Hiba súlyossága", "Jegyzőkönyvbe felvéve", "Határidő",
        "Státusz", "Kiszabható bírság összege, szankciós listában szereplő sorszáma"
    ];

    data[12][0] = "Sorszám";
    data[12][1] = "Ellenőrzéskor a helyszínen dolgozó cégek listája";

    // Számozott sorok
    for (let i = 13; i <= 20; i++) {
        data[i][0] = (i - 12).toString();
    }
    data[21][0] = "A fenti jegyzőkönyv tartalma az érintett cégek aláírása nélkül is érvényesnek tekintendő!";

    // Egyesített cellák beállítása
    const mergeCells = [
        { row: 0, col: 3, rowspan: 1, colspan: 5 },
        { row: 0, col: 9, rowspan: 1, colspan: 2 },
        { row: 1, col: 0, rowspan: 1, colspan: 12 },
        { row: 3, col: 2, rowspan: 1, colspan: 2 },
        { row: 4, col: 2, rowspan: 1, colspan: 2 },
        { row: 5, col: 2, rowspan: 1, colspan: 2 },
        { row: 5, col: 7, rowspan: 1, colspan: 4 },
        { row: 6, col: 2, rowspan: 1, colspan: 2 },
        { row: 6, col: 7, rowspan: 1, colspan: 4 },
        { row: 8, col: 3, rowspan: 1, colspan: 5 },
        { row: 8, col: 9, rowspan: 1, colspan: 2 },
        { row: 12, col: 1, rowspan: 1, colspan: 2 },
        { row: 13, col: 1, rowspan: 1, colspan: 2 },
        { row: 12, col: 5, rowspan: 9, colspan: 7 },
        { row: 14, col: 1, rowspan: 1, colspan: 2 },
        { row: 15, col: 1, rowspan: 1, colspan: 2 },
        { row: 16, col: 1, rowspan: 1, colspan: 2 },
        { row: 16, col: 3, rowspan: 2, colspan: 2 },
        { row: 17, col: 1, rowspan: 1, colspan: 2 },
        { row: 18, col: 1, rowspan: 1, colspan: 2 },
        { row: 19, col: 1, rowspan: 1, colspan: 2 },
        { row: 20, col: 1, rowspan: 1, colspan: 2 },
        { row: 21, col: 0, rowspan: 1, colspan: 12 }
    ];

    // Üres sorok jelölése
    [2, 7, 9].forEach(row => {
        mergeCells.push({ row, col: 0, rowspan: 1, colspan: 12 });
    });

    // localStorage ürítése
    localStorage.removeItem('rowColors');

    // A kívánt kezdeti oszlop szélességek
    const initialColWidths = [
        40,   // 1. oszlop: 40px
        180,  // 2. oszlop: 180px
        180,  // 3. oszlop: 180px
        100,   // 4. oszlop: 80px
        160,  // 5. oszlop: 120px
        120,  // 6. oszlop: 120px
        150,  // 7. oszlop: 120px
        120,  // 8. oszlop: 120px
        130,  // 9. oszlop: 120px
        90,   // 10. oszlop: 90px
        100,   // 11. oszlop: 90px
        110   // 12. oszlop: 110px
    ];

    // A kívánt kezdeti sor magasságok
    const initialRowHeights = Array(22).fill(30); // Alapértelmezett magasság minden sornak
    
    // Speciális magasságú sorok beállítása
    initialRowHeights[0] = 80;  // 1. sor: 
    // 2-9. sor marad 30px
    initialRowHeights[10] = 180; // 11. sor: 180px
    initialRowHeights[11] = 180; // 
    initialRowHeights[12] = 70; // 
    initialRowHeights[13] = 50; // 
    initialRowHeights[14] = 50; // 
    initialRowHeights[15] = 50; // 
    initialRowHeights[16] = 50; // 
    initialRowHeights[17] = 50; // 
    initialRowHeights[18] = 50; // 
    initialRowHeights[19] = 50; // 
    initialRowHeights[20] = 50; // 
    
    // Táblázat létrehozása a kezdeti beállításokkal
    displayEditableTable(data, mergeCells, initialColWidths, initialRowHeights);
});

// Jegyzőkönyv betöltése
document.getElementById('loadReportBtn').addEventListener('click', () => {
    const projectId = document.getElementById('projectId').value;

    fetch(`/reports/${projectId}/report`)
        .then(response => response.json())
        .then(data => {
            console.log("Frontend: API válasz a betöltéshez:", data);

            if (data.success && data.data) {
                const mergeCells = data.mergeCells || [];
                const colWidths = Array.isArray(data.colWidths) && data.colWidths.length ? data.colWidths : undefined;
                const rowHeights = Array.isArray(data.rowHeights) && data.rowHeights.length ? data.rowHeights : undefined;
                const cellStyles = data.cellStyles || [];

                console.log("Frontend: Betöltött adatok:", { data: data.data, mergeCells, colWidths, rowHeights, cellStyles });

                displayEditableTable(data.data, mergeCells, colWidths, rowHeights);

                // A cellastílusok beállítása a setupInitialCellStyles függvény segítségével
                if (cellStyles && Array.isArray(cellStyles)) {
                    setTimeout(() => {
                        // **FONTOS**: A `setupInitialCellStyles` függvényt már módosítottuk az előző lépésben,
                        // hogy felismerje a GCS URL-eket. Így ez a hívás itt már helyes.
                        setupInitialCellStyles(hot, { cellStyles: cellStyles });
                        console.log("Frontend: Kezdeti cellastílusok beállítva a betöltés után.");
                    }, 300); // Kis késleltetés a táblázat inicializálódásához
                } else {
                    console.log("Frontend: Nincsenek cellastílusok a betöltött adatokban vagy nem tömb formátumban érkeztek.");
                }

            } else {
                alert(data.message || 'Nem található jelentés.');
            }
        })
        .catch(error => {
            console.error('Frontend: Hiba történt a jelentés betöltésekor:', error);
        });
});

// Jegyzőkönyv mentése
document.getElementById('saveReportBtn').addEventListener('click', async () => {
    const projectId = document.getElementById('projectId').value;

    if (!hot) {
        alert('Nincs betöltött jegyzőkönyv a mentéshez!');
        return;
    }

    // Megerősítő alert hozzáadása
    const confirmSave = window.confirm('Biztosan szeretné menteni a jegyzőkönyvet?');
    if (!confirmSave) {
        return; // Ha a felhasználó a "Nem" gombra kattint, a mentés megszakad
    }

    // Alapadatok összegyűjtése
    const data = hot.getData(); // **Ez a `data` már GCS URL-eket fog tartalmazni, ha képek vannak**
    const mergePlugin = hot.getPlugin('mergeCells');
    const currentMergeCells = mergePlugin
        ? mergePlugin.mergedCellsCollection.mergedCells
        : [];

    // Oszlop és sor méretek lekérése
    const columnSizes = Array.from(
        { length: hot.countCols() },
        (_, index) => hot.getColWidth(index)
    );

    const rowSizes = Array.from(
        { length: hot.countRows() },
        (_, index) => hot.getRowHeight(index)
    );

    // Cellastílusok összegyűjtése a cellMeta-ból
    const cellStyles = [];
    const totalRows = hot.countRows();
    const totalCols = hot.countCols();

    console.log("Frontend: Cellastílusok összegyűjtése a cellMeta-ból...");
    for (let row = 0; row < totalRows; row++) {
        for (let col = 0; col < totalCols; col++) {
            const cellMeta = hot.getCellMeta(row, col);
            const styleObject = {};

            if (cellMeta.backgroundColor) {
                styleObject.backgroundColor = cellMeta.backgroundColor;
            }
            if (cellMeta.color) {
                styleObject.color = cellMeta.color;
            }
            if (cellMeta.fontWeight) {
                styleObject.fontWeight = cellMeta.fontWeight;
            }
            if (cellMeta.fontSize) {
                styleObject.fontSize = cellMeta.fontSize;
            }
            if (cellMeta.textAlign) {
                styleObject.textAlign = cellMeta.textAlign;
            }
            if (cellMeta.borderColor) {
                styleObject.borderColor = cellMeta.borderColor;
            }
            if (cellMeta.className) {
                styleObject.className = cellMeta.className;
            }
            if (cellMeta.rotation !== undefined) {
                styleObject.rotation = cellMeta.rotation;
            }

            // Csak akkor adjuk hozzá a cellához a stílust, ha van legalább egy beállított stílus
            if (Object.keys(styleObject).length > 0) {
                styleObject.row = row;
                styleObject.col = col;
                cellStyles.push(styleObject);
            }
        }
    }

    // Debug: Ellenőrizzük a mentett cellastílusokat
    console.log("Frontend: Mentett cellStyles (cellMeta-ból):", cellStyles);

    try {
        const response = await fetch('/reports/save', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                data: data, // **Ez a `data` már GCS URL-eket fog tartalmazni, ha képek vannak**
                projectId: projectId,
                mergeCells: currentMergeCells,
                columnSizes: columnSizes,
                rowSizes: rowSizes,
                cellStyles: cellStyles
            }),
        });

        const result = await response.json();

        if (result.success) {
            // Itt már nem kapunk fájl útvonalat, hanem egy sikeres mentési üzenetet és a reportId-t
            alert(result.message || 'Jelentés sikeresen mentve!');
            console.log("Frontend: Jelentés mentése sikeres. Report ID:", result.reportId);
        } else {
            alert(result.message || 'Hiba történt a mentés során.');
        }
    } catch (error) {
        console.error('Hiba történt a mentéskor:', error);
        alert('Hiba történt a mentés során. Kérjük próbálja újra.');
    }
});
    </script>

<!-- .xlsx letöltés -->
<!--<form action="/reports//download" method="GET">
    <button type="submit">Letöltés .xlsx</button>
</form> -->

<!-- .pdf letöltés -->
 <form action="/reports/<%= projectId %>/download-pdf" method="GET">
    <button type="submit" class="btn-blue">Letöltés .pdf</button>
</form>
    
    <form action="/user/projects" method="GET">
        <button type="submit" class="logout-btn">Vissza a projektekhez</button>
    </form>

</body>
</html>



